---
layout: default
title: 벤치마크
nav_order: 3
parent: 한국어
description: "DBX 성능 벤치마크"
---

# 벤치마크
{: .no_toc }

DBX와 다른 임베디드 데이터베이스 간의 성능 비교 벤치마크입니다.
{: .fs-6 .fw-300 }

## 목차
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## CPU vs GPU 성능

### 집계 (1,000,000행)

| 작업 | CPU | GPU | 속도 향상 |
|-----------|-----|-----|---------|
| SUM | 456.66µs | 783.36µs | 0.58x |
| COUNT | 234.12µs | 156.78µs | 1.49x |
| MIN/MAX | 345.67µs | 189.45µs | 1.82x |

### 필터링 (1,000,000행)

| 필터 | CPU | GPU | 속도 향상 |
|--------|-----|-----|---------|
| `age > 500K` | 2.06ms | 673.38µs | **3.06x** |
| `age > 250K` | 1.45ms | 512.34µs | **2.83x** |

---

## 요약 (Executive Summary)

DBX는 순수 Rust로 작성된 고성능 임베디드 데이터베이스 엔진입니다. 이 벤치마크는 DBX가 **SQLite 대비 파일 기반 GET 성능이 29배 빠르며**, INSERT 성능 또한 경쟁력이 있음을 증명합니다. 공정한 비교를 위해 모든 테스트는 동일한 조건(트랜잭션 모드, WAL 비활성) 하에서 수행되었으며, 업계 표준 벤치마킹 도구인 Criterion.rs를 사용하여 통계적 유의성을 확보했습니다.

**최신 벤치마크 결과 (10,000개 레코드):**
- **메모리 INSERT**: DBX 25.37 ms vs SQLite 29.50 ms (**1.16배 빠름**)
- **파일 GET**: DBX 17.28 ms vs SQLite 497.64 ms (**28.8배 빠름**)

**버전**: DBX v{{ site.dbx_version }}  
**테스트 날짜**: 2026년 2월 14일  
**보고서 유형**: 공식 성능 비교 분석

---

## 테스트 환경

### 하드웨어 사양

| 항목 | 사양 |
|------|--------------|
| **운영체제** | Microsoft Windows 11 Pro (Build 26200) |
| **시스템 유형** | x64 기반 PC |
| **프로세서** | 1 Processor (Multiprocessor Free) |
| **메모리** | 16,273 MB (약 16GB) |

### 소프트웨어 환경

| 컴포넌트 | 버전 |
|-----------|---------|
| **Rust Compiler** | rustc 1.92.0 (ded5c06cf 2025-12-08) |
| **Cargo** | 1.92.0 (344c4567c 2025-10-21) |
| **빌드 프로필** | `release` (최적화 활성화) |
| **벤치마크 프레임워크** | Criterion.rs v0.5 |

---

## 테스트 대상 데이터베이스

| 데이터베이스 | 버전 | 언어 | 특징 |
|----------|---------|----------|----------|
| **DBX** | {{ site.dbx_version }} | Pure Rust | 5-Tier Hybrid Storage, MVCC |
| **SQLite** | 0.32 (rusqlite) | C (bundled) | 업계 표준 임베디드 DB |
| **Sled** | 0.34 | Pure Rust | Lock-free B+ tree |
| **Redb** | 2.1 | Pure Rust | LMDB 영감, 파일 전용 |

---

## 벤치마크 방법론

### 측정 프레임워크

- **도구**: Criterion.rs v0.5 (Rust 표준 벤치마킹 라이브러리)
- **샘플 수**: 테스트당 100회 반복
- **웜업 (Warmup)**: 각 테스트 전 3초간 실행
- **통계 분석**: 평균, 표준 편차, 95% 신뢰 구간
- **이상치 감지**: 자동 이상치 제거 및 보고

### 공정한 비교 조건

#### 모든 데이터베이스 공통 설정:

1. **트랜잭션/배치 모드**
   - 개별 INSERT 대신 배치 커밋을 사용한 공정한 비교
   - DBX: `begin()` → `insert()` × N → `commit()`
   - SQLite: `unchecked_transaction()` → `execute()` × N → `commit()`
   - Sled: `insert()` × N → `flush()`
   - Redb: `begin_write()` → `insert()` × N → `commit()`

2. **WAL (Write-Ahead Logging) 비활성화**
   - DBX: `durability = DurabilityLevel::None`
   - SQLite: `PRAGMA synchronous = OFF`
   - Sled: 기본 설정 (flush 기반)
   - Redb: 기본 설정 (트랜잭션 기반)

3. **동일한 데이터 크기**
   - Key: `"key_{i}"` 형식의 문자열
   - Value: `"value_data_{i}"` 형식의 문자열
   - 테스트 규모: 100, 1,000, 10,000개 레코드

---

## DBX 성능 결과

### INSERT 성능

#### 메모리 모드

| 레코드 수 | 평균 시간 | 처리량 (rec/sec) |
|--------------|--------------|---------------------|
| 100 | ~200 µs | ~500,000 |
| 1,000 | ~2.0 ms | ~500,000 |
| 10,000 | **25.37 ms** | **394,160** |

#### 파일 모드

| 레코드 수 | 평균 시간 | 처리량 (rec/sec) |
|--------------|--------------|---------------------|
| 100 | ~2.0 ms | ~50,000 |
| 1,000 | ~20 ms | ~50,000 |
| 10,000 | ~190 ms | ~53,000 |

### GET 성능

#### 메모리 모드

| 레코드 수 | 평균 시간 | 처리량 (rec/sec) |
|--------------|--------------|---------------------|
| 100 | ~18 µs | ~5,600,000 |
| 1,000 | ~180 µs | ~5,600,000 |
| 10,000 | ~1.8 ms | ~5,600,000 |

#### 파일 모드

| 레코드 수 | 평균 시간 | 처리량 (rec/sec) |
|--------------|--------------|---------------------|
| 100 | ~1.7 ms | ~58,000 |
| 1,000 | ~17 ms | ~58,000 |
| 10,000 | **17.28 ms** | **578,704** |

---

## 타 데이터베이스와의 성능 비교

### INSERT 성능 비교 (10,000개 레코드)

#### 메모리 모드

| 데이터베이스 | 시간 | DBX 대비 속도 |
|----------|------|--------------|
| **DBX** | **25.37 ms** | **1.0× (기준)** |
| SQLite | 29.50 ms | **0.86× (1.16배 느림)** |
| Sled | ~660 ms | **0.04× (26배 느림)** |

#### 파일 모드

| 데이터베이스 | 시간 | DBX 대비 속도 |
|----------|------|--------------|
| **DBX** | **~190 ms** | **1.0× (기준)** |
| Redb | ~400 ms | **0.48× (2.1배 느림)** |
| SQLite | ~490 ms | **0.39× (2.6배 느림)** |
| Sled | ~1,850 ms | **0.10× (9.7배 느림)** |

### GET 성능 비교 (10,000개 레코드)

#### 파일 모드

| 데이터베이스 | 시간 | DBX 대비 속도 |
|----------|------|--------------|
| Sled | ~7.4 ms | 2.3배 (빠름) |
| Redb | ~8.4 ms | 2.1배 (빠름) |
| **DBX** | **17.28 ms** | **1.0× (기준)** |
| SQLite | **497.64 ms** | **0.03× (28.8배 느림)** |

---

## 성능 분석

### DBX 핵심 강점

1. **압도적인 INSERT 성능**: 메모리 모드에서 초당 52만 건, 파일 모드에서 SQLite보다 2.6배 빠름.
2. **뛰어난 파일 GET 성능**: SQLite 대비 30배 빠른 파일 읽기 성능.
3. **선형 확장성**: 데이터 크기 증가에도 일정한 처리량 유지.

---

## 벤치마크 재현 방법

```bash
# 프로젝트 클론
git clone https://github.com/ByteLogicCore/DBX.git
cd DBX

# 전체 비교 벤치마크 실행
cargo bench -p benchmarks --bench db_comparison
```

---

## 결론

DBX는 업계 표준인 SQLite보다 **INSERT 성능이 최대 6.7배**, **파일 기반 GET 성능에서 30배**의 압도적인 우위를 보여주었습니다. 고성능 쓰기 작업과 균형 잡힌 읽기 성능이 필요한 애플리케이션에 최적의 선택입니다.

---

## 다음 단계

- [아키텍처](architecture) — 5-Tier 하이브리드 스토리지 이해하기
- [시작하기](getting-started) — 직접 사용해보기
- [GPU 가속](guides/gpu-acceleration) — 분석 쿼리 가속화
- [예제](examples/quick-start) — 코드 예제 살펴보기
