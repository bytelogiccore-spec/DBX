    /// UPDATE → LogicalPlan 변환
    fn plan_update(&self, update: &sqlparser::ast::Update) -> DbxResult<LogicalPlan> {
        let table = update.table.to_string();
        
        // Parse SET assignments
        let mut assignments = Vec::new();
        for assignment in &update.assignments {
            let column = assignment.id.iter().map(|i| i.value.clone()).collect::<Vec<_>>().join(".");
            let value = self.plan_expr(&assignment.value)?;
            assignments.push((column, value));
        }
        
        // Parse WHERE clause (optional)
        let filter = if let Some(selection) = &update.selection {
            Some(self.plan_expr(selection)?)
        } else {
            None
        };
        
        Ok(LogicalPlan::Update {
            table,
            assignments,
            filter,
        })
    }

    /// DELETE → LogicalPlan 변환
    fn plan_delete(&self, delete: &sqlparser::ast::Delete) -> DbxResult<LogicalPlan> {
        let table = delete.from.iter().next()
            .ok_or_else(|| DbxError::SqlNotSupported {
                feature: "DELETE without FROM".to_string(),
                hint: "DELETE must specify a table".to_string(),
            })?
            .to_string();
        
        // Parse WHERE clause (optional)
        let filter = if let Some(selection) = &delete.selection {
            Some(self.plan_expr(selection)?)
        } else {
            None
        };
        
        Ok(LogicalPlan::Delete {
            table,
            filter,
        })
    }
